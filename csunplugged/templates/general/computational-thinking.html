{% extends "general/base.html" %}

{% load i18n %}
{% load static %}
{% load django_bootstrap_breadcrumbs %}

{% block title %}
  {% trans "Computational Thinking and CS Unplugged" %}
{% endblock title %}

{% block breadcrumbs %}
  {% breadcrumb "About" "general:about" %}
  {% breadcrumb "Computational Thinking and CS Unplugged" "general:computational_thinking" %}
{% endblock breadcrumbs %}

{% block page_heading %}
  <h1>{% trans "Computational Thinking and CS Unplugged" %}</h1>
{% endblock page_heading %}

{% block left_column_content %}
  <h2>{% trans "What is Computational Thinking?" %}</h2>

  <p>
    {% blocktrans trimmed %}
    The world we live in has become a digital one, filled with technology and driven by Computer Science.
    Software and technology have transformed every subject and job area, from science and medicine, to art history and psychology.
    Digital technology is ubiquitous.
    To be informed and empowered citizens, the next generation of students need to understand this digital world that they live in.
    {% endblocktrans %}
  </p>

  <p>
    {% blocktrans trimmed %}
    This is why Computational Thinking has been called the ‘21st Century Skill Set’, and is important for everyone to learn.
    It is critical to understanding how the digital world works, for harnessing the power of computers to solve tough problems, and making great things happen!
    It also enables us to think critically about not just the benefits of certain technologies, but also the potential harm, ethical implications, or unintended consequences of these.
    {% endblocktrans %}
  </p>

  <p>
    {% blocktrans trimmed %}
    But what exactly is Computational Thinking? Let’s have a look at a technical definition...
    {% endblocktrans %}
  </p>

  <blockquote class="blockquote blockquote-reverse">
    <p class="mb-0">
      {% blocktrans trimmed %}
      "Computational Thinking is the thought processes involved in formulating problems and their solutions so that the solutions are represented in a form that can be effectively carried out by an information-processing agent."
      {% endblocktrans %}
    </p>
    <footer class="blockquote-footer">
      Cuny, Snyder, Wing, 2010
    </footer>
  </blockquote>

  <p>
    {% blocktrans trimmed %}
    Phew, it’s quite a mouthful isn’t it?
    But, as we like to say at CS Unplugged, it’s just big words for simple ideas!
    'Information-processing agent' means anything that follows a set of instructions to complete a task (we call this 'computing').
    Most of the time this 'agent' means a computer or other type of digital device - but it could also be a human!
    We’ll refer to it as a computer to make things a bit simpler.
    To represent solutions in a way that a computer can carry them out, we have to represent them as a step by step process - an <strong>algorithm</strong>.
    To create these algorithmic solutions we apply some special problem solving skills to.
    These skill are what make up Computational Thinking!
    And they are skills that are transferrable to any field.
    {% endblocktrans %}
  </p>

  <p>
    {% blocktrans trimmed %}
    Computational Thinking could be described as 'thinking like a Computer Scientist', but it is now an important skill for everyone to learn, whether they want to be a Computer Scientist or not!
    It’s interesting, and important, to note that Computational Thinking, and Computer Science, aren’t entirely about computers, they are more about <strong>people</strong>.
    You might think that we write programs for computers, but really we write programs for people - to help them communicate, find information, and solve problems.
    {% endblocktrans %}
  </p>

  <p>
    {% blocktrans trimmed %}
    For example, you might use an app on a smartphone to get directions to a friend's house; the app is an example of a computer program, and the smartphone is the "information processing agent" that runs the program for us.
    Whoever designed the algorithm for working out the best route, and all the details like the interface and how to store the map, applied computational thinking to design the system.
    But they didn't design it for the sake of the smartphone; they designed it to help the person using the smartphone.
    {% endblocktrans %}
  </p>

  <h2>{% trans "Computational Thinking in CS Unplugged" %}</h2>

  {% blocktrans trimmed %}
  <p>

    Throughout the lessons and units in CS Unplugged there are many links to Computational Thinking.
    Teaching Computational Thinking through CS Unplugged activities teaches students how to:
  </p>

  <ul>
    <li>describe a problem,</li>
    <li>identify the important details needed to solve this problem,</li>
    <li>break the problem down into small, logical steps,</li>
    <li>use these steps to create a process (algorithm) that solves the problem,</li>
    <li>and then evaluate this process.</li>
  </ul>
  {% endblocktrans %}

  <p>
    {% blocktrans trimmed %}
    These skills are transferable to any other curriculum area, but are particularly relevant to developing digital systems and solving problems using the capabilities of computers.</p>
    {% endblocktrans %}

  <p>
    {% blocktrans trimmed %}
    These Computational Thinking concepts are all connected to each other and support each other, but it's important to note that not all aspects of Computational Thinking will necessarily happen in every unit or lesson.
    In each unit and lesson we've highlighted the important connections for you to observe your students in action.
    {% endblocktrans %}
  </p>

  <p>
    {% blocktrans trimmed %}
    There are a number of definitions of Computational Thinking, but most have a set of 5 or 6 problem solving skills that Computational Thinking embodies.
    For the Unplugged project we've identified the following six CT skills that are often mentioned in the literature; they are described below, and at the end of each Unplugged lesson we've identified ways that these skills appeared in the lesson, to help you see the CT connection with the lessons.
    {% endblocktrans %}
  </p>

  <h2>{% trans "Computational Thinking skills" %}</h2>

  <details class="panel-ct-algorithm" open="open">
    <summary>
      <strong>{% trans "Algorithmic thinking" %}</strong>
      <img class="inline-image float-{{LANGUAGE_END}}" src="{% static 'img/general/ct-algorithm.png' %}">
    </summary>
    <div class="boxed-text-content">
      <p>
        {% blocktrans trimmed %}
        Algorithms are at the heart of Computational Thinking and Computer Science, because in Computer Science the solutions to problems are not simply an answer (e.g. ‘42’, or a fact), they are algorithms.
        An algorithm is a step-by-step process that solves a problem or completes a task.
        If you follow the algorithm's steps correctly, you will arrive at a correct solution, even for different inputs.
        For example, we can use an algorithm to find the shortest route between two locations on a map; the same algorithm can be used for any pair of starting and finishing points, so the solution depends on the input to the algorithm.
        If we know the algorithm for solving a problem then we can solve that problem easily, whenever we want, without having to think! We can just follow the steps.
        Computers can’t think for themselves, so they need to be given algorithms to do things.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        Algorithmic thinking is the process of creating algorithms.
        When we create an algorithm to solve a problem, we call this an algorithmic solution.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        Computational algorithms (the kind that can run on digital devices) have relatively few ingredients because digital devices only have a few types of instruction that they can follow; the main things they can do are receive input, provide output, store values, follow instructions in a sequence, choose between options, and repeat instructions in a loop.
        Despite how limited this range of instructions is, we've described everything that digital devices can compute, and this is why algorithms are described restricted to these elements.
        {% endblocktrans %}
      </p>
    </div>
  </details>

  <details class="panel-ct-abstraction" open="open">
    <summary>
      <strong>{% trans "Abstraction" %}</strong>
      <img class="inline-image float-{{LANGUAGE_END}}" src="{% static 'img/general/ct-abstraction.png' %}">
    </summary>
    <div class="boxed-text-content">
      <p>
        {% blocktrans trimmed %}
        Abstraction is all about simplifying things to help us manage complexity.
        It requires identifying what the most important aspects of a problem are and hiding the other specific details that we don’t need to focus on.
        The important aspects can be used to create a model, or simplified representation, of the original thing we were dealing with.
        We can then work with this model to solve the problem, rather than having to deal with all the nitty gritty details at once.
        Computer Scientists often work with multiple levels of abstraction.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        We use abstraction often in our everyday lives, for example when we use maps.
        Maps show us a simplified version of the world by leaving out unnecessary details, like where every individual tree in a park is, and only keeping the most relevant information the map reader will need, such as roads and street names.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        Digital devices use abstraction all the time; they try to hide as much unnecessary information from the user as possible.
        For example, let's say you took a nice scenic photo on your last camping trip, and now you want to edit it on your laptop and adjust the colours in it.
        Normally we could do this by opening a picture editing program, adjusting some colour sliders or maybe choosing a filter.
        When you do this there are a lot of complicated operations happening which the computer is hiding from you.
        {% endblocktrans %}
      </p>

      <figure class="figure d-block text-center">
        <img src="{% static 'img/topics/binary-picture-showing-bits.png' %}" class="content-image figure-img img-fluid" alt="A picture with a magnifying glass showing the binary digits within the image.">
      </figure>

      <p>
        {% blocktrans trimmed %}
        The picture you took is stored on the computer as a big list of pixels, which are each a different colour, and each colour is represented by a set of numbers, and each of these numbers are stored as binary digits!
        That’s a lot of information. Imagine if when you adjusted the colours you had to go through and look at all the colour values of every pixel and change each and every one of those!
        That’s what the computer is doing for you, but since you don’t need to know this to accomplish your goal the computer hides this information away.
        {% endblocktrans %}
      </p>
    </div>
  </details>

  <details class="panel-ct-decomposition" open="open">
    <summary>
      <strong>{% trans "Decomposition" %}</strong>
      <img class="inline-image float-{{LANGUAGE_END}}" src="{% static 'img/general/ct-decomposition.png' %}">
    </summary>
    <div class="boxed-text-content">
      <p>
        {% blocktrans trimmed %}
        Decomposition is about breaking down problems into smaller, more manageable, parts, and then focusing on solving each of these smaller problems.
        We can break a complex problem down until the smaller parts are so simple they become easy to solve.
        The solutions to each of these smaller, and simpler, problems build up to a solution to the big problem we started with.
        Decomposition helps make large problems much less intimidating!
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        Decomposition is an important skill for creating algorithms and processes that can be implemented on a computing device, because computers need very specific instructions.
        They need to be told each of the tiny steps they need to follow in order to do things.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        For example the overall task of making a cake can be decomposed into several smaller tasks, each of which can be performed easily.
        {% endblocktrans %}
      </p>

      {% blocktrans trimmed %}
      <p><strong>Make cake</strong></p>

      <ol>
        <li>Bake cake
          <ol>
            <li>Put ingredients in bowl (butter, sugar, egg, flour)</li>
            <li>Mix</li>
            <li>Pour into tin</li>
            <li>Put in oven for 30mins</li>
            <li>Take out of tin</li>
          </ol>
        </li>
        <li>Make icing</li>
        <li>Put on cake</li>
      </ol>
      {% endblocktrans %}
    </div>
  </details>

  <details class="panel-ct-pattern" open="open">
    <summary>
      <strong>{% trans "Generalising and patterns" %}</strong>
      <img class="inline-image float-{{LANGUAGE_END}}" src="{% static 'img/general/ct-pattern.png' %}">
    </summary>
    <div class="boxed-text-content">
      <p>
        {% blocktrans trimmed %}
        Generalising is also referred to as 'pattern recognition and generalisation'.
        Generalisation is taking a solution (or part of a solution) to a problem and generalising it so it can be applied to other similar problems and tasks.
        Since solutions in Computer Science are algorithms, this means we take an algorithm and make it general enough that it can be used for a range of problems.
        This process involves abstraction, because to make something more general we have to remove unnecessary details that are related to a specific problem or situation, but are not important to how the algorithm functions.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        Spotting patterns is an important part of this process, when we think about problems we might recognise similarities between them and that they can be solved in similar ways.
        This is called pattern matching, and it’s something we do naturally all the time in our daily life.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        Generalised algorithms can be reused for a whole group of similar problems, which means we can come up with solutions quickly and effectively.
        {% endblocktrans %}
      </p>
    </div>
  </details>

  <details class="panel-ct-evaluation" open="open">
    <summary>
      <strong>{% trans "Evaluation" %}</strong>
      <img class="inline-image float-{{LANGUAGE_END}}" src="{% static 'img/general/ct-evaluation.png' %}">
    </summary>
    <div class="boxed-text-content">
      <p>
        {% blocktrans trimmed %}
        Evaluation is about identifying the possible solutions to a problem and judging which is the best to use, if they will work in some situations but not others, and how they can be improved.
        When judging our solutions we need to think about a range of factors.
        For example how much time it will take these processes (algorithms) to solve the problem and will it reliably solve the problem, or if there are certain situations where it will perform in a very different way.
        Evaluation is something we do a lot in our everyday lives.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        There are different ways we can evaluate our algorithmic solutions.
        We can test their speed by implementing them on a computer; or we can analyse them by counting or calculating how many steps they are likely to take.
        We can test that our algorithmic solutions work correctly by giving them lots of different inputs, and checking they work as expected.
        When we do this we need to think about the different inputs we test, because we don’t want to check every possible input (often there's an infinite number of possible inputs!), but we still need to know if our algorithmic solutions will work for all inputs.
        Testing is something Computer Scientists and programmers do all the time.
        But because we can't usually test every possible input, we also try to evaluate a system using logical reasoning.
        {% endblocktrans %}
      </p>
    </div>
  </details>

  <details class="panel-ct-logic" open="open">
    <summary>
      <strong>{% trans "Logic" %}</strong>
      <img class="inline-image float-{{LANGUAGE_END}}" src="{% static 'img/general/ct-logic.png' %}">
    </summary>
    <div class="boxed-text-content">
      <p>
        {% blocktrans trimmed %}
        When trying to solve problems we need to think logically.
        Logical reasoning is about trying to make sense of things by observing, collecting data, thinking about the facts you know, and then figuring things out based on what you already know.
        It helps us use our existing knowledge to establish rules and check facts.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        For example, suppose you are writing software that works out the shortest route to a location from your house.
        In the following map it's 2 minutes to the library if you head north from your house, but if you head south it's 3 minutes to the next intersection.
        You might wonder if there's a better route to the library if you start by heading south, but logically there can't be because you'll already have walked for 3 minutes to get to the intersection.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        At a deeper level, computers are built entirely on logic.
        They use 'True' and 'False' values, and use something called 'Boolean expressions', like “is age > 5”, to make decisions in computer programs.
        {% endblocktrans %}
      </p>

      <p>
        {% blocktrans trimmed %}
        Tracking down a bug in a program also requires logical thinking, to work out where, and why, something in the program is going wrong.
        {% endblocktrans %}
      </p>
    </div>
  </details>
{% endblock left_column_content %}
