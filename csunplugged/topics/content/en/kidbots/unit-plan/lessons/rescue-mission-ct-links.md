{panel type="ct-algorithm"}

# Algorithmic thinking

Creating a sequence of instructions for this lesson exercises algorithmic problem solving, as it requires students to create an algorithm to accomplish a task.
Computational algorithms are based on input, output, storage, sequence, selection and iteration.
This exercise focuses on sequencing instructions.

#### Examples of what you could look for:

Are students able to see what the result will be of their program before it is executed?
Did students successfully create a set of step by step instructions for the robot to follow?

{panel end}

{panel type="ct-abstraction"}

# Abstraction

In this lesson we have abstracted out writing a program and using a programming language to very basic instructions of move forward, turn left or turn right.
Students write these instructions down in familiar words or symbols and give the instructions to the Bot verbally, which removes the need to know how to use a programming language and implement this on a computer.
This supports students to understand how sequence works in programming, without being overwhelmed with technical terminology and tools.

#### Examples of what you could look for:

Can students see the stages of programming (designing the program, testing it, and debugging it), even though the environment is removed from physical devices?

{panel end}

{panel type="ct-decomposition"}

# Decomposition

In our everyday lives we don’t often give instructions as specifically as saying “Turn right, take a step forward, take another step forward, turn right”, and it seems much more straightforward to simply say “please go over there”.
But when we program we have to be very specific because we have to tell computers exactly how to do each thing and limit ourselves to the few instructions that they can follow.
Students need to work on taking something they are familiar with, like “go to that square” and identifying the simplest individual steps that need to happen for someone to accomplish this.

Also, programs can be written incrementally; instead of trying to solve the whole problem, students were encouraged to write a few steps first, test these, and then add to them.
Breaking a program down into smaller components makes the task less overwhelming.

#### Examples of what you could look for:

Do students work on the problem incrementally?
Can they take the action of “going to the left” and break it down further to the instructions “turn left, move forward”?

{panel end}

{panel type="ct-pattern"}

# Generalising and patterns

Many different patterns are likely to emerge when students write their programs, and when students recognise these patterns they can reuse some of them multiple times, rather than having to figure out each step again.
For example, students may recognise that if they want to turn around 180° they can repeat “left” or “right” twice, and they can repeat this same sequence whenever they need to do this movement.
Or if they need to move diagonally across the grid they can take the group of instructions “left, go forward, right, go forward” (right and left swapped depending on which way you’re going) and repeat this as many times as they need to cross the board.

#### Examples of what you could look for:

When students recognise patterns in their programs and in how they move the bot do they also see that they can reuse these instruction sets whenever they need the bot to make the same movement?

{panel end}

{panel type="ct-evaluation"}

# Evaluation

There is a clear way for students to evaluate their programs in this activity, which is simply to ask themselves “did it work?”.
By testing their programs they can evaluate whether their instructions accomplish the task.

There are multiple programs students could write that will get the Bot to the goal square, but some of these are probably more efficient than others.
This could be measure be either the number of instructions, or the amount of time used.

#### Examples of what you could look for:

Did students recognise that multiple solutions (many different sets of instructions) are possible?
Were they able to compare some and evaluate which ones use fewer commands and are the fastest?
Are they able to see that measuring the time taken is a practical measure of the performance of a program, but counting the number of instructions is more consistent? (As it doesn't depend on who has the Bot and Tester roles).

{panel end}

{panel type="ct-logic"}

# Logic

When students encounter bugs in their programs they will need to logically step through their instructions one by one to locate the bug.
They will need to think about what they expect to happen when each instruction is followed, and if they do not get the result they expected they will need to identify what went wrong, why it went wrong, and how to fix it.
This requires students to apply their logical thinking skills.

#### Examples of what you could look for:

Do students go through their instructions and predict what will happen each time one is executed?
When they debug their instructions do they use a logical method to do this?
Such as stepping through each instruction one by one and checking if what they expected to happen does happen, or comparing their program to previous version which didn’t seem to contain a bug?

{panel end}
