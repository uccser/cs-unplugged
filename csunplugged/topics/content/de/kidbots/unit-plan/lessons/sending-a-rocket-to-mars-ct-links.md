{panel type="ct-algorithm"}

# Algorithmisches Denken

Creating a sequence of instructions for this lesson exercises algorithmic problem solving, as it requires students to create an algorithm to accomplish a task. Computational algorithms are based on input, output, storage, sequence, selection and iteration. This exercise focuses on sequencing instructions.

#### Worauf Sie beispielsweise achten können:

Are students able to see what the result will be of their program before it is executed? Did students successfully create a set of step by step instructions for the robot to follow?

{panel end}

{panel type="ct-abstraction"}

# Abstraktion

In this lesson we have abstracted out writing a program and using a programming language to very basic instructions of move forward, turn left or turn right. Students write these instructions down in familiar words or symbols and give the instructions to the Bot verbally, which removes the need to know how to use a programming language and implement this on a computer. This supports students to understand how sequence works in programming, without being overwhelmed with technical terminology and tools.

#### Worauf Sie beispielsweise achten können:

Can students see the stages of programming (designing the program, testing it, and debugging it), even though the environment is removed from physical devices?

{panel end}

{panel type="ct-decomposition"}

# Dekomposition

In unserem Alltag geben wir für gewöhnlich keine so spezifischen Anweisungen wie „Nach rechts drehen, einen Schritt vorwärts, einen Schritt vorwärts, nach links drehen“ und es scheint unkomplizierter zu sein, einfach zu sagen „Geh dort hinüber“. But when we program we have to be very specific because we have to tell computers exactly how to do each thing and limit ourselves to the few instructions that they can follow. Students need to work on taking something they are familiar with, like “go to that square” and identifying the simplest individual steps that need to happen for someone to accomplish this.

Also, programs can be written incrementally; instead of trying to solve the whole problem, students were encouraged to write a few steps first, test these, and then add to them. Breaking a program down into smaller components makes the task less overwhelming.

#### Worauf Sie beispielsweise achten können:

Do students work on the problem incrementally? Can they take the action of “going to the left” and break it down further to the instructions “turn left, move forward”?

{panel end}

{panel type="ct-pattern"}

# Generalisierung und Muster

Many different patterns are likely to emerge when students write their programs, and when students recognise these patterns they can reuse some of them multiple times, rather than having to figure out each step again. For example, students may recognise that if they want to turn around 180° they can repeat “left” or “right” twice, and they can repeat this same sequence whenever they need to do this movement. Or if they need to move diagonally across the grid they can take the group of instructions “left, go forward, right, go forward” (right and left swapped depending on which way you’re going) and repeat this as many times as they need to cross the board.

#### Worauf Sie beispielsweise achten können:

When students recognise patterns in their programs and in how they move the bot do they also see that they can reuse these instruction sets whenever they need the bot to make the same movement?

{panel end}

{panel type="ct-evaluation"}

# Auswertung

There is a clear way for students to evaluate their programs in this activity, which is simply to ask themselves “did it work?”. By testing their programs they can evaluate whether their instructions accomplish the task.

There are multiple programs students could write that will get the Bot to the goal square, but some of these are probably more efficient than others. This could be measure be either the number of instructions, or the amount of time used.

#### Worauf Sie beispielsweise achten können:

Did students recognise that multiple solutions (many different sets of instructions) are possible? Were they able to compare some and evaluate which ones use fewer commands and are the fastest? Haben sie erkannt, dass man durch Messen des Zeitaufwands praktische Einblicke in die Leistungsfähigkeit eines Programms erhält, dass jedoch das Zählen der Anzahl der Anweisungen folgerichtiger ist? (Da es nicht davon abhängt, wer die Rolle des Bot oder des Testers innehat.)

{panel end}

{panel type="ct-logic"}

# Logik

When students encounter bugs in their programs they will need to logically step through their instructions one by one to locate the bug. They will need to think about what they expect to happen when each instruction is followed, and if they do not get the result they expected they will need to identify what went wrong, why it went wrong, and how to fix it. This requires students to apply their logical thinking skills.

#### Worauf Sie beispielsweise achten können:

Do students go through their instructions and predict what will happen each time one is executed? When they debug their instructions do they use a logical method to do this? Such as stepping through each instruction one by one and checking if what they expected to happen does happen, or comparing their program to previous version which didn’t seem to contain a bug?

{panel end}